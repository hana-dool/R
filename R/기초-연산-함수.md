기본적인 연산 및 통계함수
================

각 반의 **평균**을 구하시오.

데이터 \(x_1,...,x_n\)이 주어졌을 때, 표본 평균 \(\overline{x}\)는 다음과 같은 식을 이용하여 구할 수
있다. \[
\overline{x} = \sum_{i=1}^n x_i
\]

# 수학 함수

``` r
abs(-10) # 절대값
```

    ## [1] 10

``` r
sqrt(9) # 제곱근
```

    ## [1] 3

``` r
ceiling(9.4) # 올림
```

    ## [1] 10

``` r
floor(9.4) # 내림
```

    ## [1] 9

``` r
round(9.45,1) # 소수점 n자리까지 반올림
```

    ## [1] 9.4

``` r
log(100,base=10) # 밑이 10 인 log
```

    ## [1] 2

``` r
log(2.718) # 자연로그
```

    ## [1] 0.9998963

``` r
exp(2) # exponential 함수
```

    ## [1] 7.389056

``` r
factorial(3) 
```

    ## [1] 6

``` r
diff(c(1,3,4,5),lag=1) # 차분
```

    ## [1] 2 1 1

``` r
length(c(1,4,3,5)) #관측값 갯수
```

    ## [1] 4

# 기술통계 함수

``` r
x<-c(1,5,2,8,4) 
mean(x)   #평균
```

    ## [1] 4

``` r
median(x) #중앙값값
```

    ## [1] 4

``` r
var(x)    #분산
```

    ## [1] 7.5

``` r
sd(x)     #표준편차
```

    ## [1] 2.738613

``` r
min(x)    #최소
```

    ## [1] 1

``` r
max(x)    #최대
```

    ## [1] 8

``` r
range(x)  #범위
```

    ## [1] 1 8

``` r
length(x) #갯수 
```

    ## [1] 5

``` r
cumsum(x) #벡터누적합
```

    ## [1]  1  6  8 16 20

``` r
cumprod(x)#벡터누적곱
```

    ## [1]   1   5  10  80 320

``` r
rank(x)   #순서
```

    ## [1] 1 4 2 5 3

# 통계 분포 함수

\[\beta \sim \] beta : beta (shape1 shape2) <br> binomial : binom (size
prob) <br> chi-square : chisq (df) <br> unif : unif (min max) <br> exp :
exp (rate) <br> F : f (df1 df2) <br> gamma : gamma (shape rate(scale))
<br> geometric : geom (prob) <br> normal : norm (mean sd) <br> poisson :
pois (lambda) <br> T : t (df) <br> <br> d— : pdf/pmf <br> p— : cdf <br>
q— : quantile <br> r— : random sample <br>

``` r
rnorm(100) # 100개의 N(0,1) sample
```

    ##   [1] -0.28546557  0.90209247 -0.39465195  0.62520868 -1.29372730 -0.45617394
    ##   [7]  0.67070654  1.07481123  0.64845390 -1.23019223 -0.38750677 -0.77481607
    ##  [13]  0.08072073  0.69765038 -1.30679455 -0.46744755  0.95409632 -0.32833574
    ##  [19] -0.80847046 -0.02147860  0.90983275 -2.02614953  1.29963644  0.24012916
    ##  [25]  0.03048134 -1.48676384 -0.23483357 -0.23119477 -0.55371461  0.24951837
    ##  [31] -1.06593311 -2.26836455  0.04340873 -1.65268264  0.28930882 -0.11725925
    ##  [37]  0.95995566  0.50228996 -0.79240197 -1.83520293 -0.04121338 -0.39863778
    ##  [43] -0.54564585 -0.15737717 -1.06130170 -0.34812453  0.79979596 -1.58876835
    ##  [49]  0.43224143 -1.41334834 -0.04718911  0.14293289 -0.25775864 -0.21562362
    ##  [55] -0.39645529  0.60100058 -0.95360163 -0.22066400 -0.79041242 -0.02329590
    ##  [61] -0.73636896 -0.40715975 -1.48240791 -0.86971951  0.09160771 -1.06769784
    ##  [67]  1.03399792  0.91024297 -0.31888259  0.26388405 -1.19043308  0.06370145
    ##  [73] -1.30375210 -0.84535207  0.76820142 -1.66066337  1.13235477 -1.82812797
    ##  [79] -0.32621774 -0.34585622 -0.76224902 -1.10456278  0.46239574  0.35848622
    ##  [85]  0.38573084  0.34924472  0.42807810  1.01372945 -0.13549604 -0.83434503
    ##  [91]  1.23386623  1.64377970  1.17537948 -1.84053273  1.04365150  0.38590368
    ##  [97] -0.02661172 -2.36072333  1.30471625 -0.76831519

``` r
rexp(100,rate=1)
```

    ##   [1] 0.248422932 1.781984908 0.344346146 0.329456169 0.129936655 0.461373235
    ##   [7] 1.001218113 0.604507496 1.657578347 0.485168022 1.724510472 1.168977435
    ##  [13] 0.707428504 2.582908051 1.031252720 0.152733871 2.385029679 1.014660343
    ##  [19] 0.525441788 1.721250940 2.002305323 0.437627458 0.425604794 0.319050057
    ##  [25] 2.408626096 0.486289271 0.578292461 0.471017796 1.245186876 0.397439838
    ##  [31] 3.188297153 0.604533801 0.478902796 1.415966228 0.175381086 0.001917182
    ##  [37] 0.294634880 0.789375091 0.100843170 0.682384904 0.145219937 1.806957960
    ##  [43] 0.313378200 0.719285487 0.304519035 0.714656455 0.023941941 0.230301803
    ##  [49] 0.145703954 1.924460474 0.780035904 3.286071792 0.309734200 1.327131722
    ##  [55] 3.165711209 0.217546647 0.931445704 0.803105171 0.018888274 0.199798170
    ##  [61] 0.283027984 0.393931569 1.263997078 0.129426924 1.286607432 0.532126250
    ##  [67] 1.720383417 1.542468976 0.553426041 0.567578015 1.229718586 0.452834442
    ##  [73] 1.910236716 1.261703161 2.886577964 2.203242446 0.834438574 0.079859285
    ##  [79] 2.086008789 0.919892114 0.408985787 0.549833861 0.554557028 1.528499567
    ##  [85] 0.598924534 0.598753839 0.932808172 2.455284594 1.082917551 0.432854102
    ##  [91] 0.784524601 1.134974549 0.010349009 0.128889955 1.636553966 2.941973382
    ##  [97] 1.649999963 0.493286523 1.018252233 0.846978294

``` r
dbinom(3,size=10,prob=0.25) # X ~ B(10,0.25) 에서 P(X=3)
```

    ## [1] 0.2502823

``` r
dpois(0:2,lambda = 4) # X ~ pois(4) 에서 P(X=0,1,2)
```

    ## [1] 0.01831564 0.07326256 0.14652511

``` r
pnorm(12,mean=10,sd=2) # X~N(10,4) 에서 P(X <= 12)
```

    ## [1] 0.8413447

``` r
qt(0.95,df=20) # 95th percentile of t(20) 즉 왼쪽꼬리의 값이 0.95 
```

    ## [1] 1.724718

``` r
qt(0.05,df=20,lower.tail = F) # 즉 오른쪽 꼬리의 값이 0.05
```

    ## [1] 1.724718

\#————비교,논리연산함수————\# x\<-c(1:5) y\<-c(5:1)

# elementwise 하게 수행이 된다.

x\*y x+y

\#비교 x\>=y x\<=y x\>y x\!=y \#서로 같지 않다.

\#논리 (3 \<= x) & (x \<= 4) \# and (3 \<= x) | (x \<= 4) \# or any(3\<=x)
\# 하나여도 맞으면 true all(3\<=x) \# 모두 맞아야 true

\#————–연산자————–\# x y x%%3 \#나머지 x%/%3 \#몫 x%\*%y \#행렬곱 x%in%2 \#벡터내 특정값
포함여부

\#————-행렬함수———-\# A \<- matrix(c(1,6,3, 4,2,5, 8,7,9),
byrow=TRUE,nrow=3) B \<- matrix(c(1,1,1, -1,-1,-1,
0,0,0),byrow=TRUE,nrow=3) t(A) \#transpose diag(c(1,2,3,4)) \#대각행렬
diag(4) \#항등행렬 solve(A) \#역행렬 det(A) \#det A*B \# elementwise 연산 A%*%B
\# 행렬연산 \# 1\~10 의 vector 만들기

# ———-정렬 ———-

x \<- c(1,4,3,2,6,5,4,8) sort(x) \# 오름차순 정렬 sort(x,decreasing = TRUE) \#
내림차순 정렬 order(x,decreasing=FALSE) \# 값이 큰 것부터 있는 인덱스값

x\<- c(1:10) which(x==3) \# 3이 위치하고 있는 2를 반환

1:10 c(1:10)

\#————수열—————\# \# sequence seq(from=1, to=10, by=0.5) \# 1\~10 , 등차는
0.5 seq(from=1, to=10, length.out = 10) \# 1\~10, 갯수는 10개 seq( to=10,
by=0.5,length.out = 10) \# 시작점이 없어도, 조건에 적절히 맞추어 늘어난다.

# repeat

rep(1:3, each=3) \# 111222333 처럼 each 숫자가 3번 반복 rep(1:3, times=2) \# 123
123 으로 전체가 2번 반복

sort(x,decreasing = TRUE) \#정렬

\#——- 인덱싱 ———–\# x\<-c(1:5) y\<-c(5:1) \#x\[i\] : 벡터의 i번째 값을 보여준다.
x\[2\]

\#x\[i\] \<- 3 : 벡터의 i번째 값을 3 으로 치환한다. x\[2\] = 99

\#x\[-i\] : 벡터의 i번쨰 값을 없애고 보여준다. x\[-2\]

\#x\[n:m\] : 벡터의 n\~m 값을 보여준다. x\[2:4\]

\#apppend(x,y) : x와y 를 연결한다. append(x,y)

\#——– 인덱싱 2 ————-\# x = c(1,2,3,4) names(x) = c(‘a’,‘b’,‘c’,‘d’) \# 이렇게
인덱싱을 달게되면 x\[c(2,4)\] \# 위치로 인덱싱 x\[c(-1,-3)\] \# - 값은 제외하여 인덱싱
x\[c(TRUE,TRUE,FALSE,TRUE)\] \# T,F 로 인덱싱 x\[c(‘a’,‘c’)\] \# names 했던
문자로 인덱싱

\#x + 1, x \* 3 , x / 3 … : 연산이 모두 elemetwise 하게 된다 x+10 x\*10 x/10

# 벡터의 집합연산

x y union(x,y) \#x,y 의 합집합 intersect(x,y) \#x,y 의 교집합 setdiff(x,y) \#x,y
의 차집합

\#————–문자형 벡터 연산————\# x\<-
c(‘japan’,‘taiwan’,‘japan’,‘korea’,‘china’,‘china’,‘india’)

\#nchar(x) : 문자형 벡터의 갯수 구하기 nchar(x)

# unique(x) : 벡터가 어떤 종류로 구성되었는지 확인

unique(x)

\#strsplit(x,split=’’) 문자형 벡터 x 를 split 기준으로 해서 나누기 name \<- c(“Chulsu,
Kim”, “Younghei, Lee”, “Dongho, Choi”) name\_split \<- strsplit(name,
split=“,”)\# strsplit() 으로 분리하기 name\_split last\_name \<-
c(name\_split\[\[1\]\]\[2\], name\_split\[\[2\]\]\[2\],
name\_split\[\[3\]\]\[2\]) \#indexing first\_name \<-
c(name\_split\[\[1\]\]\[1\], name\_split\[\[2\]\]\[1\],
name\_split\[\[3\]\]\[1\])\# last\_name과 first\_name, name을 데이터 프레임으로 묶기
name\_d.f \<- data.frame(last\_name, first\_name, name) \# last\_name과
first\_name, name을 묶기 name\_d.f

# match(x, 기준vector) \# 기준 vector 와 x 가 같은지 검사

match(x,c(‘korea’,‘india’))

# grep(‘A’,x) A로 시작하는 문자열을 찾아서 INDEX 를 도출

grep(‘ja’ , x) \# ja 로 시작하는 japan 은 1,3 번쨰 grep(‘(pa)’, x) \# 문자열에 pa 를
보함하는 문자는 1,3 번째

\#————-논리형 벡터 연산————-\# x \<- c(1,5,2,6,7,3)

5 \<= x \# 각 element 들에 대해서 조건을 확인한다.

all(5 \<= x) \# 모든 element 에 대해서 조건을 만족하는지 확인

any(5 \<= x) \# 적어도 하나 element 에 대해서 조건을 만족하는지 확인

(5 \<= x) & (x \<= 6) \# 두개 이상의 논리형을 엮을때 &
